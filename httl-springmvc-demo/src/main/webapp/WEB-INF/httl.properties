# 加载顺序 httl-default.properties > httl-<mode>.properties > httl.properties
# JVM -D选项(只会读取以httl.开头键值，读入的键值会把键名的httl.去掉)java -Dhttl.reloadable=true -Dhttl.modes+=debug
# OS环境变量(只会读取以httl_开头键值，读入的键值会把键名的httl_去掉，并将下划线换成点号) export httl_reloadable=true
# 后面的优先生效

# modes+=develop 加载httl-develop.properties
# 内置debug模式 加载 httl-debug.properties
modes+=debug

# 以复数命名的配置项，表示可以填多个值，用逗号分隔
# =覆盖上一级或缺省配置
# +=上一级或缺省配置值的前面插入值,多值配置时
# -=表示在上一级或缺省配置值上删除值,多值配置时

#导入包名后可在模板内用短类名
import.packages+=com.demo.domain

#导入方法
#如果需要setEngine()注入引擎实例或setXxx(String)注入配置项,可以导入非静态方法,但静态方法编译后更快,为啥//TODO
import.methods+=com.demo.utils.TemplateToolMethods

#HTTL不允许调用void方法，保持模板的无副作用，以及多次渲染的幂等性
#如果有一些方法有返回值，可以通过forbid.methods配置禁止，防止开发人员误调用。
#forbid.methods+=longtime

#导入变量类型声明,还是需要put到context中,MVC会导入request/response/session/application/cookie/parameter/header
#import.variables+=Book xxx

#导入宏,可在其它任意模板中使用
#import.macros=common_macros.httl

#导入属性获取器 //TODO code如何使用
#import.getters=get,getProperty,getAttribute

#导入大小获取器 //TODO code如何使用
#import.sizers=size,length,getSize,getLength

#如果最前和最后一个值相同，表示可以循环
import.sequences+=金 木 水 火 土 金

#template loader
#loaders=httl.spi.loaders.ClasspathLoader

template.directory=/WEB-INF/templates
message.basename=/WEB-INF/messages
input.encoding=UTF-8
output.encoding=UTF-8

code.directory=target/log/java
compile.directory=target/log/classes

# 旧的模板不会被卸载，经常改文件会导致内存perm区越来越大，只能在开发阶段使用//TODO为啥
reloadable=true

#生成一份class,编译期就会将模板文件转换成byte[],必须用template.render(Map,OutputStream)否则数据转换会导致性能更低
#AbstractTemplate.render() out = convertOut(out); ResponseOutConverter 找到地方但没看到转换//TODO
output.stream=false

#生成一份class,模板文件转换成char[],必须用template.render(Map,Writer)否则数据转换会导致性能更低, webapp中其实默认false, using httl-web.properties
#如果都false只生成writer模板
output.writer=false

#预编译所有模板.httl --> .java,否则访问时才编译
precompiled=false

#模板源码和模板文本都不编译到字节码中,模板大于8K时，会导致JVM的JIT优化失效
#通过一个Map缓存做中介，把模板源码和模板文本都放到了runtime属性中，以节省内存perm区大小//TODO
source.in.class=true
text.in.class=true

#for dev, 如果模板编译失败,获取更详细的编译出错信息
lint.unchecked=false

#动态插值过滤会在~输出的时候~执行，需小心过滤引起性能问题
#value.filters=httl.spi.filters.EscapeXmlFilter

#模板文本过滤会在~编译的时候~执行，编译时即把模板文本替换掉，不影响输出时的性能
#text.filters=httl.spi.filters.ClearBlankLineFilter #静态文本中的空白行删除
#             httl.spi.filters.CompressBlankFilter #静态文本中的连续空白符压缩成单个空格

#filters=等价于同时设置value.filters和text.filters

#移除指令所在行空白 default true
remove.directive.blank.line=true

#变量决策即从哪里获取变量.
#内置的MVC集成，已经自动导入ServletResolver，从request、session、servletContext等中获取变量
#EngineResolver 读取到httl.properties配置项
#SystemResolver JVM启动参数java -Dkey=value(System.getProperty())
#EnvironmentResolver 环境变量System.getenv()
#resolvers=httl.spi.resolvers.GlobalResolver,httl.spi.resolvers.ContextResolver


